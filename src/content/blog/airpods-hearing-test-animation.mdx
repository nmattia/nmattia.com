---
title: "Todo"
description: "Todo"
og_image: /images/airpods/airpods-hearing-test.png
pubDate: 2025-04-29
tags:
  - webgl
  - js
  - frontend
---

This is an article on how to reproduce an iPhone animation with WebGL. [mention which concepts will be visited]

{/* more */}

[back story]

import BlueSky from "./airpods-hearing-test-animation/BlueSky.astro";

<BlueSky />

If you squint at the animation, you'll see it's actually made up of lots of small dots (3328 of them to be exact). We'll use a simplified version to explain the various things necessary to draw it: first draw a dot, then radial symmetries, and finally overlapping dots with alpha. [clarify simplifications, introduce slices and dot bars, motivate use of shaders for performance]

![image](/images/airpods/simplified.png)

_Simplified representation of the Hearing Test animation dots_

[brief outline: first single dot, then slices & symmetries, then alpha]

## Drawing a single Dot

The simplest thing to do is start with a single dot. In WebGL, the shader program is run once for
every pixel.

> [!NOTE]
>
> Technically we need to talk about "fragments" though for simplicity we'll use "pixels"

Let's start simple: let's draw a dot.

![image](/images/airpods/single-dot.png)

_Only pixels within the unit circle will be opaque_

[explain each pixel is like a small computer running the program and setting its color depending on the result, ]

[say we will be computing the _opacity_ at every pixel based on the position]

```glsl
float get_opacity(vec2 uv) {
    return ... /* opacity definition here */;
}

void main() {
    vec4 rgb = vec4(...);
    vec2 position = ...;
    gl_FragColor = get_opacity(position) * rgb;
}
```

[add note that "position" is input only because quad-shader but inputs could be other things; link to quad-shader for details]

```glsl
float get_opacity(vec2 uv) {
    if(sqrt(uv.x * uv.x + uv.y * uv.y) < 1.) {
        return 1.;
    } else {
        return 0.;
    }
}

...
```

[simplify using `step()` and `length()`]
We can use the handy `step(edge, v)` function where the result is `0` if `v < edge` (`v` a scalar) and `1` if `v > edge`.

With the GLSL built-in `length()` that uses Pythagoras, `step(edge, length(uv))` will be `0.` if `uv` is inside the unit circle, and `1.` otherwise.

We will set the opacity depending on this value, so we invert the result with `1. - result` (where `result = step(...)`), so that if `result` is `1.` we get `0.`, and if `result` is `0.` we get `1.`:

[add note that `step(x, y) == 1. - step(y, x)`]

If you struggle to make sense of it, try with calculating the return value for different pixel positions. For instance, to confirm that the pixel at $[0, 0]$ is indeed opaque:

```
uv := vec2(0., 0.)
=> length(uv) =
    sqrt(uv.x*uv.x + uv.y*uv.y) =
    sqrt(0.*0. + 0.*0.) = 0.
=> length(uv) = 0. => length(uv) < 1.
=> step(1., length(uv)) = 0.
=> get_opacity(uv) = 1. - 0. = 1.
=> pixel is opaque
```

This gives us the dot shown below.

import StaticDot from "./airpods-hearing-test-animation/StaticDot.astro";

<StaticDot />

Now let's do something a bit more difficult. Let's change the size of the dot.

![image](/images/airpods/transform.png)

_Two of the many pixels rendering a dot (disc) of radius `r` centered at `c`_

So effectively we run the same calculation as above to check whether we are inside a unit circle, but we first move.

import MovingDot from "./airpods-hearing-test-animation/MovingDot.astro";

<MovingDot />

[name of the game: define shapes around origin and then translate `uv`]

https://iquilezles.org/articles/distfunctions2d/

## Repeating dots for free

Now that we can draw one dot and position it wherever we want, let's see how we can draw _multiple_ dots. In general we want repeating patterns, and in the world of shaders we can actually have any number of repetitions for free.

For our animations, we can take advantage of the fact that it's [radially symmetrical](https://en.wikipedia.org/wiki/Rotational_symmetry).

In order to simplify things we will work with [polar coordinates](https://en.wikipedia.org/wiki/Polar_coordinate_system). As a quick refresher, polar coordinates are a way of representing a point as $(\rho, \theta)$ where $\rho$ is the distance to the origin $[0,0]$ and $\theta$ [explain theta].

$$\theta = arctan(y,x), \rho = \sqrt{x^2 + y^2}$$

In GLSL we can use the following primitives:

```glsl
float theta = atan(uv.y, uv.x)
float rho = length(uv)
```

The trick is to define a general pattern (a gradient to start simple) in terms of $\theta$, and then lie about $\theta$ and repeat it.

![image](/images/airpods/slice.png)

_The slice that is described once and repeated N times_

> [!NOTE]
>
> To simplifiy calculations we work with $\tau = 2 \pi$, referred to as `TAU` in the code. See also [The Tau Manifest](https://www.tauday.com/tau-manifesto). Bottom line: one full rotation is one $\tau$.

If we `mod` the value of theta, pixels with $\theta \in [0, \alpha]$ will get the regular gradient. But then, the gradient will repeat for $\theta \in [\alpha, 2\alpha]$.

Using this we can repeat the pattern any number of times with constant time -- technicall $O(1)$ w.r.t to the number of symmetries or repeated "slices".

import RadialSymmetries from "./airpods-hearing-test-animation/RadialSymmetries.astro";

<RadialSymmetries />

This means that, as long as we can describe a pattern in terms of `theta` and `rho`, we can repeat that pattern radially as many times as we want without any extra resource usage.

## Radially Repeating Dots

Gradients are pretty, but we're here to draw dots. We use the same trick to make $\theta$ repeat, and we use the checks from earlier to figure out if the pixel lands in a dot.

import RadialDots from "./airpods-hearing-test-animation/RadialDots.astro";

<RadialDots />

One added thing here is `slice_ix`, which is the index of the slice the current pixel is in. This is useful if you want to vary a parameter based on _which_ slice you're in (if you just used $\theta$ the value would vary within the same slice). This is used in this snippet to give each dot a different opacity.

![image](/images/airpods/slice-indices.png)

_TODO_

## discs-bad

Now that we have a pattern that we can repeat radially, let's figure out how we might create repeating dots within a slice.

![image](/images/airpods/discs.png)

_Dots separated by distance `d`_

The `mod` trick can be used for other parameters, for instance `x` if we want linear symmetries instead of radial symmetries. But we run into an issue. Can you spot it before playing with the animation below?

import AlphaDiscsBad from "./airpods-hearing-test-animation/AlphaDiscsBad.astro";

<AlphaDiscsBad />

The pattern is repeated exactly and the dots do not mix with each other. This also happens with $\theta$ above, but as long as the dots are smaller than the slices, this is ok

![image](/images/airpods/overlap.png)

Let's see how we can resolve this.

## discs

Here unfortunately there is no way to do this in constant time. While there would be workarounds if we had overlapping opaque discs of different colors, there is no workaround when the opacity is changing. For this we need to calculate the opacity at every point, taking all other (potentially overlapping) discs into account.

Simply multiplying the opacity does not work. The reason is that two discs have opacity `.5`, the resulting opacity should be _greater_ than the individual opacities, though $0.5 \cdot 0.5 = 0.25 < 0.5$.

The "transparency" on the other hand can be multiplied. Is this a truth of nature? Don't know, but works well enough in practice. [explain in terms of probability of light going through a material]

![image](/images/airpods/photon.png)

Let's say in general transparency is $t = 1 - o$. Let's say all the different layers have transparency $t_0, t_1, ...$. Then $o = 1 - t = 1 - (t_0 \cdot t_1 \cdot ...) = 1 - \prod_i t_i = 1 - \prod (1 - o_i)$

This gives us the following:

import AlphaDiscs from "./airpods-hearing-test-animation/AlphaDiscs.astro";

<AlphaDiscs />

Note that this operation is commutative, so it doesn't matter what order we look at the dots -- though this would be different if we were mixing colors as well.

[broader range of alpha blending/compositing: https://en.wikipedia.org/wiki/Alpha_compositing]

## final

Putting everything together we get the following. Since everything is rendered in real time, we can animate it based on time, as we as make it react to user interaction (clicks).

import AirpodsHearingTest from "./airpods-hearing-test-animation/AirpodsHearingTest.astro";

<AirpodsHearingTest />
