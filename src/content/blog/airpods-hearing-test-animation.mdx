---
title: "Recreating an iOS Animation with WebGL: an Interactive Tutorial"
description: "A deep dive into how to recreate a radially symmetric iOS animation using shaders, with performance-friendly WebGL tricks and visual insights."
og_image: /images/airpods/airpods-hearing-test.png
pubDate: 2025-04-29
tags:
  - webgl
  - js
  - frontend
---

This article explores how to reproduce an iPhone animation I really liked, using WebGL and GLSL shaders. We'll dive into several foundational concepts in graphics programming: fragment shaders, radial symmetry and compositing with transparency.

{/* more */}

You may have seen this animation in iOS (or iPadOS) if you've tried AirPods' hearing test. It’s fluid, elegant, and deceptively simple. On closer inspection, it’s made up of thousands of small fading dots. Recreating this animation isn't just fun—it’s also a great way to learn how GPU-based rendering works at a low level using GLSL.

import BlueSky from "./airpods-hearing-test-animation/BlueSky.astro";

<BlueSky />

If you squint at the animation, you'll see it's actually made up of lots of small dots (3328 of them to be exact). To make it manageable, we’ll first work through a simplified version with fewer elements. We’ll explore how to draw a single dot, create repeated radial patterns (like pizza slices), and handle overlapping semi-transparent elements (like a row of dots).

![image](/images/airpods/simplified.png)

_Simplified representation of the Hearing Test animation dots_

In short, we will **start with one dot**, then leverage the animation's **radial symmetry** to render lots of dots for free, and finally learn how to blend overlapping dots with **alpha transparency**.

## Drawing a single Dot

In WebGL, a fragment shader runs once per pixel. Think of each pixel as a mini processor that decides its own color based on math -- though all pixels share the same program, and the only variation is the pixel's position passed as an input.

Here we will simplify and use a single, known color and only vary the _opacity_ of the pixels.

```glsl
float get_opacity(vec2 uv) {
    return ... /* opacity definition here */;
}

void main() {
    vec4 rgb = vec4(...) /* known color */;
    vec2 position = ... /* pixel position magically passed in */;
    gl_FragColor = get_opacity(position) * rgb;
}
```

> [!NOTE]
>
> The shader programs we write here technically run once for every "fragment" though we simplify with pixels. It is every pixel of the canvas bc of quad-shader. Also they take their position as input, also because of quad-shader.
> [todo: add link to webglfundamentals or something]

So if we are a pixel, and we know our position, how do we go about figuring out our opacity so that all pixels together draw a dot?

![image](/images/airpods/single-dot.png)

_Only pixels within the unit circle will be opaque_

We'll define the opacity for each pixel based on how close it is to the origin $(0,0)$. If it’s within a distance (or radius) $1$, it’s opaque. Otherwise, it’s transparent.

```glsl
float get_opacity(vec2 uv) {
    if(sqrt(uv.x * uv.x + uv.y * uv.y) < 1.) {
        return 1.;
    } else {
        return 0.;
    }
}

...
```

[TODO: add codepen]

Here we calculate the distance of the pixel to the origin using Pythagoras' formula of $d = \sqrt{x^2 + y^2}$ and, if $d < 1$, set the pixel to fully opaque (`1.`) and otherwise fully transparent (`0.`). This code is very explicit bordering on verbose, though we can leverage two built-in GLSL constructs: [`length()`](https://registry.khronos.org/OpenGL-Refpages/gl4/html/length.xhtml) and [`step()`](https://registry.khronos.org/OpenGL-Refpages/gl4/html/step.xhtml).

> [!NOTE]
>
> `step(edge, v)` returns `1.` if `edge < v`, and 0. otherwise. Therefore, `1. - step(1., distance)` gives `1.` when inside the circle and `0.` outside. The value of `1. - step(edge, v)` is the same as `step(v, edge)` (arguments swapped) though I find it easier to remember that `edge` is always the first argument; hence the `1. - ...` part.

Using `length()` and `step()` we can simplify the code, and the implementation of `get_opacity` might look like this:

import StaticDot from "./airpods-hearing-test-animation/StaticDot.astro";

<StaticDot />

Try calculating a few values manually to build intuition:

```
uv := vec2(0., 0.)
=> length(uv) =
    sqrt(uv.x*uv.x + uv.y*uv.y) =
    sqrt(0.*0. + 0.*0.) = 0.
=> length(uv) = 0. => length(uv) < 1.
=> step(1., length(uv)) = 0.
=> get_opacity(uv) = 1. - 0. = 1.
=> pixel is opaque
```

Drawing a dot with a given radius was easy enough, let's now move the dot!

![image](/images/airpods/transform.png)

_Two of the many pixels rendering a dot (disc) of radius `r` centered at `c`_

So effectively we run the same calculation as above to check whether we are inside a unit circle, but we first move.

import MovingDot from "./airpods-hearing-test-animation/MovingDot.astro";

<MovingDot />

This idea is central: define shapes at the origin, then transform coordinates. If you ever need to draw shapes more complexe than dots, see Inigo Quilez’s [distance functions](https://iquilezles.org/articles/distfunctions2d/) reference for a deeper dive.

## Repeating Patterns for Free with Modulo

Now that we can draw one dot and position it wherever we want, let's see how we can draw _multiple_ dots. In general we want repeating patterns, and in the world of shaders we can actually have any number of repetitions for free.

For our animations, we can take advantage of the fact that it's [radially symmetrical](https://en.wikipedia.org/wiki/Rotational_symmetry).

In order to simplify things we will work with [polar coordinates](https://en.wikipedia.org/wiki/Polar_coordinate_system). As a quick refresher, polar coordinates are a way of representing a point as $(\rho, \theta)$ where $\rho$ is the distance to the origin $[0,0]$ and $\theta$ [explain theta].

$$\theta = arctan(y,x), \rho = \sqrt{x^2 + y^2}$$

In GLSL we can use the following primitives:

```glsl
float theta = atan(uv.y, uv.x)
float rho = length(uv)
```

The trick is to define a general pattern (a gradient to start simple) in terms of $\theta$, and then lie about $\theta$ and repeat it.

![image](/images/airpods/slice.png)

_The slice that is described once and repeated N times_

> [!NOTE]
>
> To simplifiy calculations we work with $\tau = 2 \pi$, referred to as `TAU` in the code. See also [The Tau Manifest](https://www.tauday.com/tau-manifesto). Bottom line: one full rotation is one $\tau$.

If we `mod` the value of theta, pixels with $\theta \in [0, \alpha]$ will get the regular gradient. But then, the gradient will repeat for $\theta \in [\alpha, 2\alpha]$.

Using this we can repeat the pattern any number of times with constant time -- technicall $O(1)$ w.r.t to the number of symmetries or repeated "slices".

import RadialSymmetries from "./airpods-hearing-test-animation/RadialSymmetries.astro";

<RadialSymmetries />

This means that, as long as we can describe a pattern in terms of `theta` and `rho`, we can repeat that pattern radially as many times as we want without any extra resource usage.

### Radially Repeating Dots

Gradients are pretty, but we're here to draw dots. We use the same trick to make $\theta$ repeat, and we use the checks from earlier to figure out if the pixel lands in a dot.

import RadialDots from "./airpods-hearing-test-animation/RadialDots.astro";

<RadialDots />

One added thing here is `slice_ix`, which is the index of the slice the current pixel is in. This is useful if you want to vary a parameter based on _which_ slice you're in (if you just used $\theta$ the value would vary within the same slice). This is used in this snippet to give each dot a different opacity.

![image](/images/airpods/slice-indices.png)

_TODO_

## Repeating Dots Horizontally

Next, we need multiple dots per slice. Let's consider the slice with index `0`, extending along the horizontal axis towards (plus) inifinity. We'll have several dots, each at distance `d` from each other, potentially overlapping:

![image](/images/airpods/discs.png)

_Dots separated by distance `d`_

We saw earlier that we could leverage the modulo operator to repeat patterns. This `mod` trick can be used for other parameters, for instance `x` if we want linear symmetries instead of radial symmetries. But we run into an issue.

Can you spot it before playing with the animation below?

import AlphaDiscsBad from "./airpods-hearing-test-animation/AlphaDiscsBad.astro";

<AlphaDiscsBad />

The pattern is repeated exactly and the dots do not mix with each other. This also happens with $\theta$ above, but as long as the dots are smaller than the slices, this is ok.

![image](/images/airpods/overlap.png)

Let's see how we can resolve this.

### Compositing Overlapping Dots

Here unfortunately there is no way to do this in constant time, like with the radial repetitions. While there would be workarounds if we had overlapping opaque discs of different colors, there is no workaround when the opacity is changing. For this we need to calculate the opacity at every point, taking all other (potentially overlapping) discs into account.

If two overlapping dots have opacity `.5` we may be tempted to multiply the individual opacities to get the overlap's opacity, though a quick example shows that this won't work: if the dots have opacity `.5`, the resulting opacity should be _greater_ than the individual opacities, though $0.5 \cdot 0.5 = 0.25 < 0.5$.

![image](/images/airpods/photon.png)

The "transparency" on the other hand can be multiplied. Is this a truth of nature? Don't know, but works well enough in practice. [explain in terms of probability of light going through a material]

Let's say in general transparency is $t = 1 - o$. Let's say all the different layers have transparency $t_0, t_1, ...$. Here's how we calculate the total opacity:

$$o = 1 - t = 1 - (t_0 \cdot t_1 \cdot ...) \\ = 1 - \prod t_i \\ = 1 - \prod (1 - o_i)$$

This gives us the following:

import AlphaDiscs from "./airpods-hearing-test-animation/AlphaDiscs.astro";

<AlphaDiscs />

Note that this operation is commutative, so it doesn't matter what order we look at the dots -- though this would be different if we were mixing colors as well.

[broader range of alpha blending/compositing: https://en.wikipedia.org/wiki/Alpha_compositing]

## Final Result & Conclusion

Putting everything together we get the following. Since everything is rendered in real time, we can animate it based on time, as we as make it react to user interaction (clicks).

import AirpodsHearingTest from "./airpods-hearing-test-animation/AirpodsHearingTest.astro";

<AirpodsHearingTest />
